stack-pointer: X2
constant-registers:
  X0: 0x0000000000000000
register-classes:
  GPR: "X[0-9][0-9]?"
  FPR: "F[0-9][0-9]?_D"
  FPR_W: "F[0-9][0-9]?_F"
subregisters:
  FPR_W: "FPR"
instructions:
  # F extension
  FADD_S:
    func: |
      define i64 @FADD_S(i64 %0, i64 %1, i10 %rm) {
         %4 = trunc i64 %0 to i32
         %5 = trunc i64 %1 to i32
         %6 = bitcast i32 %4 to float
         %7 = bitcast i32 %5 to float
         %8 = fadd float %6, %7
         %9 = bitcast float %8 to i32
         %10 = zext i32 %9 to i64
         %11 = shl i64 4294967295, 32 ; 0xFFFFFFFF00000000
         %12 = or i64 %10, %11
         ret i64 %12
      }
  FSUB_S:
    func: |
      define i64 @FSUB_S(i64 %0, i64 %1, i10 %rm) {
         %4 = trunc i64 %0 to i32
         %5 = trunc i64 %1 to i32
         %6 = bitcast i32 %4 to float
         %7 = bitcast i32 %5 to float
         %8 = fsub float %6, %7
         %9 = bitcast float %8 to i32
         %10 = zext i32 %9 to i64
         %11 = shl i64 4294967295, 32 ; 0xFFFFFFFF00000000
         %12 = or i64 %10, %11
         ret i64 %12
      }
  FMUL_S:
    func: |
      define i64 @FMUL_S(i64 %0, i64 %1, i10 %rm) {
         %4 = trunc i64 %0 to i32
         %5 = trunc i64 %1 to i32
         %6 = bitcast i32 %4 to float
         %7 = bitcast i32 %5 to float
         %8 = fmul float %6, %7
         %9 = bitcast float %8 to i32
         %10 = zext i32 %9 to i64
         %11 = shl i64 4294967295, 32 ; 0xFFFFFFFF00000000
         %12 = or i64 %10, %11
         ret i64 %12
      }
  FDIV_S:
    func: |
      define i64 @FDIV_S(i64 %0, i64 %1, i10 %rm) {
         %4 = trunc i64 %0 to i32
         %5 = trunc i64 %1 to i32
         %6 = bitcast i32 %4 to float
         %7 = bitcast i32 %5 to float
         %8 = fdiv float %6, %7
         %9 = bitcast float %8 to i32
         %10 = zext i32 %9 to i64
         %11 = shl i64 4294967295, 32 ; 0xFFFFFFFF00000000
         %12 = or i64 %10, %11
         ret i64 %12
      }
  FSQRT_S:
    func: |
      define i64 @FSQRT_S(i64 %0, i10 %rm) {
         %3 = trunc i64 %0 to i32
         %4 = bitcast i32 %3 to float
         %5 = call float @llvm.sqrt.f32(float %4)
         %6 = bitcast float %5 to i32
         %7 = zext i32 %6 to i64
         %8 = shl i64 4294967295, 32 ; 0xFFFFFFFF00000000
         %9 = or i64 %7, %8
         ret i64 %9
      }
  FMIN_S:
    func: |
      define i64 @FMIN_S(i64 %0, i64 %1) {
         %4 = trunc i64 %0 to i32
         %5 = trunc i64 %1 to i32
         %6 = bitcast i32 %4 to float
         %7 = bitcast i32 %5 to float
         %8 = call float @llvm.minnum.f32(float %6, float %7)
         %9 = bitcast float %6 to i32
         %10 = zext i32 %9 to i64
         %11 = shl i64 4294967295, 32 ; 0xFFFFFFFF00000000
         %12 = or i64 %10, %11
         ret i64 %12
      }
  FMAX_S:
    func: |
      define i64 @FMAX_S(i64 %0, i64 %1) {
         %4 = trunc i64 %0 to i32
         %5 = trunc i64 %1 to i32
         %6 = bitcast i32 %4 to float
         %7 = bitcast i32 %5 to float
         %8 = call float @llvm.maxnum.f32(float %6, float %7)
         %9 = bitcast float %6 to i32
         %10 = zext i32 %9 to i64
         %11 = shl i64 4294967295, 32 ; 0xFFFFFFFF00000000
         %12 = or i64 %10, %11
         ret i64 %12
      }
  FEQ_S:
    func: |
      define i64 @FEQ_S(i64 %0, i64 %1) {
         %4 = trunc i64 %0 to i32
         %5 = trunc i64 %1 to i32
         %6 = bitcast i32 %4 to float
         %7 = bitcast i32 %5 to float
         %8 = fcmp oeq float %6, %7
         %9 = zext i1 %8 to i64
         ret i64 %9
      }
  FLT_S:
    func: |
      define i64 @FLT_S(i64 %0, i64 %1) {
         %4 = trunc i64 %0 to i32
         %5 = trunc i64 %1 to i32
         %6 = bitcast i32 %4 to float
         %7 = bitcast i32 %5 to float
         %8 = fcmp olt float %6, %7
         %9 = zext i1 %8 to i64
         ret i64 %9
      }
  FLE_S:
    func: |
      define i64 @FLE_S(i64 %0, i64 %1) {
         %4 = trunc i64 %0 to i32
         %5 = trunc i64 %1 to i32
         %6 = bitcast i32 %4 to float
         %7 = bitcast i32 %5 to float
         %8 = fcmp ole float %6, %7
         %9 = zext i1 %8 to i64
         ret i64 %9
      }
  FSGNJ_S:
    func: |
      define i64 @FSGNJ_S(i64 %0, i64 %1) {
         %4 = trunc i64 %0 to i32
         %5 = trunc i64 %1 to i32
         %6 = bitcast i32 %4 to float
         %7 = bitcast i32 %5 to float
         %8 = call float @llvm.copysign.fp32(float %6, float %7)
         %9 = bitcast float %8 to i32
         %10 = zext i32 %9 to i64
         %11 = shl i64 4294967295, 32 ; 0xFFFFFFFF00000000
         %12 = or i64 %10, %11
         ret i64 %12
      }
  FSGNJN_S:
    func: |
      define i64 @FSGNJN_S(i64 %0, i64 %1) {
         %4 = trunc i64 %0 to i32
         %5 = trunc i64 %1 to i32
         %6 = bitcast i32 %4 to float
         %7 = bitcast i32 %5 to float
         %8 = fneg float %7
         %9 = call float @llvm.copysign.fp32(float %6, float %8)
         %10 = bitcast float %9 to i32
         %11 = zext i32 %10 to i64
         %12 = shl i64 4294967295, 32 ; 0xFFFFFFFF00000000
         %13 = or i64 %11, %12
         ret i64 %13
      }
  FSGNJX_S:
    func: |
      define i64 @FSGNJX_S(i64 %0, i64 %1) {
         %4 = trunc i64 %0 to i32
         %5 = trunc i64 %1 to i32
         %6 = bitcast i32 %4 to float
         %7 = bitcast i32 %5 to float
         %8 = fmul float %6, %7 ; XOR-ed sign
         %9 = call float @llvm.copysign.fp32(float %6, float %8)
         %10 = bitcast float %9 to i32
         %11 = zext i32 %10 to i64
         %12 = shl i64 4294967295, 32 ; 0xFFFFFFFF00000000
         %13 = or i64 %11, %12
         ret i64 %13
      }
  FCLASS_S:
    func: |
      define i64 @FCLASS_S(i64 %0) {
        %3 = trunc i64 %0 to i32
        %4 = bitcast i32 %3 to float
        %is_snan = call i1 @llvm.is.fpclass(float %4, i32 1)
        %is_qnan = call i1 @llvm.is.fpclass(float %4, i32 2)
        %is_neginf = call i1 @llvm.is.fpclass(float %4, i32 4)
        %is_negnorm = call i1 @llvm.is.fpclass(float %4, i32 8)
        %is_negsub = call i1 @llvm.is.fpclass(float %4, i32 16)
        %is_negzero = call i1 @llvm.is.fpclass(float %4, i32 32)
        %is_poszero = call i1 @llvm.is.fpclass(float %4, i32 64)
        %is_possub = call i1 @llvm.is.fpclass(float %4, i32 128)
        %is_posnorm = call i1 @llvm.is.fpclass(float %4, i32 256)
        %is_posinf = call i1 @llvm.is.fpclass(float %4, i32 512)
        ; shifting
        %is_neginf_shifted = zext i1 %is_neginf to i64 ; 0th
        %is_negnorm_zext = zext i1 %is_negnorm to i64
        %is_negnorm_shifted = shl i64 %is_negnorm_zext, 1
        %is_negsub_zext = zext i1 %is_negsub to i64
        %is_negsub_shifted = shl i64 %is_negsub_zext, 2
        %is_negzero_zext = zext i1 %is_negzero to i64
        %is_negzero_shifted = shl i64 %is_negzero_zext, 3
        %is_poszero_zext = zext i1 %is_poszero to i64
        %is_poszero_shifted = shl i64 %is_poszero_zext, 4
        %is_possub_zext = zext i1 %is_possub to i64
        %is_possub_shifted = shl i64 %is_possub_zext, 5
        %is_posnorm_zext = zext i1 %is_posnorm to i64
        %is_posnorm_shifted = shl i64 %is_posnorm_zext, 6
        %is_posinf_zext = zext i1 %is_posinf to i64
        %is_posinf_shifted = shl i64 %is_posinf_zext, 7
        %is_snan_zext = zext i1 %is_snan to i64
        %is_snan_shifted = shl i64 %is_snan_zext, 8
        %is_qnan_zext = zext i1 %is_qnan to i64
        %is_qnan_shifted = shl i64 %is_qnan_zext, 9
        %5 = or i64 %is_neginf_shifted, %is_negnorm_shifted
        %6 = or i64 %5, %is_negsub_shifted
        %7 = or i64 %6, %is_negzero_shifted
        %8 = or i64 %7, %is_poszero_shifted
        %9 = or i64 %8, %is_possub_shifted
        %10 = or i64 %9, %is_posnorm_shifted
        %11 = or i64 %10, %is_posinf_shifted
        %12 = or i64 %11, %is_snan_shifted
        %13 = or i64 %12, %is_qnan_shifted
        ret i64 %13
      }
  FCVT_S_W:
    func: |
      define i64 @FCVT_S_W(i64 %0, i10 %rm) {
         %3 = trunc i64 %0 to i32
         %4 = sitofp i32 %3 to float
         %5 = bitcast float %4 to i32
         %6 = zext i32 %5 to i64
         %7 = shl i64 4294967295, 32 ; 0xFFFFFFFF00000000
         %8 = or i64 %6, %7
         ret i64 %8
      }
  FCVT_S_L:
    func: |
      define i64 @FCVT_S_L(i64 %0, i10 %rm) {
         %3 = trunc i64 %0 to i32
         %4 = sitofp i32 %3 to float
         %5 = bitcast float %4 to i32
         %6 = zext i32 %5 to i64
         %7 = shl i64 4294967295, 32 ; 0xFFFFFFFF00000000
         %8 = or i64 %6, %7
         ret i64 %8
      }
  FCVT_S_WU:
    func: |
      define i64 @FCVT_S_WU(i64 %0, i10 %rm) {
         %3 = trunc i64 %0 to i32
         %4 = uitofp i32 %3 to float
         %5 = bitcast float %4 to i32
         %6 = zext i32 %5 to i64
         %7 = shl i64 4294967295, 32 ; 0xFFFFFFFF00000000
         %8 = or i64 %6, %7
         ret i64 %8
      }
  FCVT_W_S:
    func: |
      define i64 @FCVT_W_S(i64 %0, i10 %rm) {
         %3 = trunc i64 %0 to i32
         %4 = bitcast i32 %3 to float
         %5 = fptosi float %4 to i32
         %6 = sext i32 %5 to i64
         ret i64 %6
      }
  FCVT_L_S:
    func: |
      define i64 @FCVT_L_S(i64 %0, i10 %rm) {
         %3 = trunc i64 %0 to i32
         %4 = bitcast i32 %3 to float
         %5 = fptosi float %4 to i64
         ret i64 %5
      }
  FCVT_LU_S:
    func: |
      define i64 @FCVT_LU_S(i64 %0, i10 %rm) {
         %3 = trunc i64 %0 to i32
         %4 = bitcast i32 %3 to float
         %5 = fptoui float %4 to i64
         ret i64 %5
      }
  FCVT_WU_S:
    func: |
      define i64 @FCVT_WU_S(i64 %0, i10 %rm) {
         %3 = trunc i64 %0 to i32
         %4 = bitcast i32 %3 to float
         %5 = fptoui float %4 to i32
         %6 = zext i32 %5 to i64
         %7 = shl i64 4294967295, 32 ; 0xFFFFFFFF00000000
         %8 = or i64 %6, %7
         ret i64 %8
      }
  # FIXME: this is not entirely correct as FMV and other convertions to 32-bit X register do not modify upper 32 bits
  FMV_X_W:
    func: |
      define i64 @FMV_X_W(i64 %0, i10 %rm) {
         ret i64 %0
      }
  FMV_W_X:
    func: |
      define i64 @FMV_W_X(i64 %0) {
         ret i64 %0
      }
  FMADD_S:
    func: |
      define i64 @FMADD_S(i64 %0, i64 %1, i64 %2, i10 %rm) {
         %4 = trunc i64 %0 to i32
         %5 = trunc i64 %1 to i32
         %6 = trunc i64 %2 to i32
         %7 = bitcast i32 %4 to float
         %8 = bitcast i32 %5 to float
         %9 = bitcast i32 %6 to float
         %11 = call float @llvm.fmuladd.f32(float %7, float %8, float %9)
         %12 = bitcast float %11 to i32
         %13 = zext i32 %12 to i64
         %14 = shl i64 4294967295, 32 ; 0xFFFFFFFF00000000
         %15 = or i64 %13, %14
         ret i64 %15
      }
  FMSUB_S:
    func: |
      define i64 @FMSUB_S(i64 %0, i64 %1, i64 %2, i10 %rm) {
         %4 = trunc i64 %0 to i32
         %5 = trunc i64 %1 to i32
         %6 = trunc i64 %2 to i32
         %7 = bitcast i32 %4 to float
         %8 = bitcast i32 %5 to float
         %9 = bitcast i32 %6 to float
         %10 = fneg float %9
         %11 = call float @llvm.fmuladd.f32(float %7, float %8, float %10)
         %12 = bitcast float %11 to i32
         %13 = zext i32 %12 to i64
         %14 = shl i64 4294967295, 32 ; 0xFFFFFFFF00000000
         %15 = or i64 %13, %14
         ret i64 %15
      }
  FNMADD_S:
    func: |
      define i64 @FNMADD_S(i64 %0, i64 %1, i64 %2, i10 %rm) {
         %4 = trunc i64 %0 to i32
         %5 = trunc i64 %1 to i32
         %6 = trunc i64 %2 to i32
         %7 = bitcast i32 %4 to float
         %8 = bitcast i32 %5 to float
         %9 = bitcast i32 %6 to float
         %10 = fneg float %7
         %11 = fneg float %9
         %12 = call float @llvm.fmuladd.f32(float %10, float %8, float %11)
         %13 = bitcast float %12 to i32
         %14 = zext i32 %13 to i64
         %15 = shl i64 4294967295, 32 ; 0xFFFFFFFF00000000
         %16 = or i64 %14, %15
         ret i64 %16
      }
  FNMSUB_S:
    func: |
      define i64 @FNMSUB_S(i64 %0, i64 %1, i64 %2, i10 %rm) {
         %4 = trunc i64 %0 to i32
         %5 = trunc i64 %1 to i32
         %6 = trunc i64 %2 to i32
         %7 = bitcast i32 %4 to float
         %8 = bitcast i32 %5 to float
         %9 = bitcast i32 %6 to float
         %10 = fneg float %7
         %12 = call float @llvm.fmuladd.f32(float %10, float %8, float %9)
         %13 = bitcast float %12 to i32
         %14 = zext i32 %13 to i64
         %15 = shl i64 4294967295, 32 ; 0xFFFFFFFF00000000
         %16 = or i64 %14, %15
         ret i64 %16
      }
  FLW: # Dummy implementation
    func: |
      define i64 @FLW(i64 %0, i64 %1) {
        %3 = add i64 0, 0
        ret i64 %3
      }
  FSW: # Dummy implementation
    func: |
      define void @FSW(i64 %0, i64 %1, i64 %2) {
        ret void
      }
  # D extension
  FADD_D:
    func: |
      define i64 @FADD_D(i64 %0, i64 %1, i10 %rm) {
      entry:
         %4 = bitcast i64 %0 to double
         %5 = bitcast i64 %1 to double
         %6 = fadd double %4, %5
         %7 = bitcast double %6 to i64
         %is_qnan = call i1 @llvm.is.fpclass(double %6, i32 2)
         %is_snan = call i1 @llvm.is.fpclass(double %6, i32 1)
         %is_nan = or i1 %is_snan, %is_qnan
         br i1 %is_nan, label %set_bit, label %exit
      set_bit:
         ; setting sign bit to zero
         %setb = and i64 %7, 9223372036854775807 ; 0x7FFFFFFFFFFFFFFF
         br label %exit
      exit:
         %res = phi i64 [%7, %entry], [%setb, %set_bit]
         ret i64 %res      }
  FSUB_D:
    func: |
      define i64 @FSUB_D(i64 %0, i64 %1, i10 %rm) {
      entry:
         %4 = bitcast i64 %0 to double
         %5 = bitcast i64 %1 to double
         %6 = fsub double %4, %5
         %7 = bitcast double %6 to i64
         %is_qnan = call i1 @llvm.is.fpclass(double %6, i32 2)
         %is_snan = call i1 @llvm.is.fpclass(double %6, i32 1)
         %is_nan = or i1 %is_snan, %is_qnan
         br i1 %is_nan, label %set_bit, label %exit
      set_bit:
         ; setting sign bit to zero
         %setb = and i64 %7, 9223372036854775807 ; 0x7FFFFFFFFFFFFFFF
         br label %exit
      exit:
         %res = phi i64 [%7, %entry], [%setb, %set_bit]
         ret i64 %res
      }
  FMUL_D:
    func: |
      define i64 @FMUL_D(i64 %0, i64 %1, i10 %rm) {
      entry:
         %4 = bitcast i64 %0 to double
         %5 = bitcast i64 %1 to double
         %6 = fmul double %4, %5
         %7 = bitcast double %6 to i64
         %is_qnan = call i1 @llvm.is.fpclass(double %6, i32 2)
         %is_snan = call i1 @llvm.is.fpclass(double %6, i32 1)
         %is_nan = or i1 %is_snan, %is_qnan
         br i1 %is_nan, label %set_bit, label %exit
      set_bit:
         ; setting sign bit to zero
         %setb = and i64 %7, 9223372036854775807 ; 0x7FFFFFFFFFFFFFFF
         br label %exit
      exit:
         %res = phi i64 [%7, %entry], [%setb, %set_bit]
         ret i64 %res
      }
  FDIV_D:
    func: |
      define i64 @FDIV_D(i64 %0, i64 %1, i10 %rm) {
      entry:
         %4 = bitcast i64 %0 to double
         %5 = bitcast i64 %1 to double
         %6 = fdiv double %4, %5
         %7 = bitcast double %6 to i64
         %is_qnan = call i1 @llvm.is.fpclass(double %6, i32 2)
         %is_snan = call i1 @llvm.is.fpclass(double %6, i32 1)
         %is_nan = or i1 %is_snan, %is_qnan
         br i1 %is_nan, label %set_bit, label %exit
      set_bit:
         ; setting sign bit to zero
         %setb = and i64 %7, 9223372036854775807 ; 0x7FFFFFFFFFFFFFFF
         br label %exit
      exit:
         %res = phi i64 [%7, %entry], [%setb, %set_bit]
         ret i64 %res
      }
  FSQRT_D:
    func: |
      define i64 @FSQRT_D(i64 %0, i10 %rm) {
      entry:
         %3 = bitcast i64 %0 to double
         %4 = call double @llvm.sqrt.f64(double %3)
         %5 = bitcast double %4 to i64
         %is_qnan = call i1 @llvm.is.fpclass(double %4, i32 2)
         %is_snan = call i1 @llvm.is.fpclass(double %4, i32 1)
         %is_nan = or i1 %is_snan, %is_qnan
         br i1 %is_nan, label %set_bit, label %exit
      set_bit:
         ; setting sign bit to zero
         %setb = and i64 %5, 9223372036854775807 ; 0x7FFFFFFFFFFFFFFF
         br label %exit
      exit:
         %res = phi i64 [%5, %entry], [%setb, %set_bit]
         ret i64 %res
      }
  FMIN_D:
    func: |
      define i64 @FMIN_D(i64 %0, i64 %1, i10 %rm) {
         %4 = bitcast i64 %0 to double
         %5 = bitcast i64 %1 to double
         %6 = call double @llvm.minnum.f64(double %4, double %5)
         %7 = bitcast double %6 to i64
         ret i64 %7
      }
  FMAX_D:
    func: |
      define i64 @FMAX_D(i64 %0, i64 %1) {
         %4 = bitcast i64 %0 to double
         %5 = bitcast i64 %1 to double
         %6 = call double @llvm.maxnum.f64(double %4, double %5)
         %7 = bitcast double %6 to i64
         ret i64 %7
      }
  FEQ_D:
    func: |
      define i64 @FEQ_D(i64 %0, i64 %1) {
         %4 = bitcast i64 %0 to double
         %5 = bitcast i64 %1 to double
         %6 = fcmp oeq double %4, %5
         %7 = zext i1 %6 to i64
         ret i64 %7
      }
  FLT_D:
    func: |
      define i64 @FLT_D(i64 %0, i64 %1) {
         %4 = bitcast i64 %0 to double
         %5 = bitcast i64 %1 to double
         %6 = fcmp olt double %4, %5
         %7 = zext i1 %6 to i64
         ret i64 %7
      }
  FLE_D:
    func: |
      define i64 @FLE_D(i64 %0, i64 %1) {
         %4 = bitcast i64 %0 to double
         %5 = bitcast i64 %1 to double
         %6 = fcmp ole double %4, %5
         %7 = zext i1 %6 to i64
         ret i64 %7
      }
  FSGNJ_D:
    func: |
      define i64 @FSGNJ_D(i64 %0, i64 %1) {
         %4 = bitcast i64 %0 to double
         %5 = bitcast i64 %1 to double
         %6 = call double @llvm.copysign.fp64(double %4, double %5)
         %7 = bitcast double %6 to i64
         ret i64 %7
      }
  FSGNJN_D:
    func: |
      define i64 @FSGNJN_D(i64 %0, i64 %1) {
         %4 = bitcast i64 %0 to double
         %5 = bitcast i64 %1 to double
         %6 = fneg double %5
         %7 = call double @llvm.copysign.fp64(double %4, double %6)
         %8 = bitcast double %7 to i64
         ret i64 %8
      }
  FSGNJX_D:
    func: |
      define i64 @FSGNJX_D(i64 %0, i64 %1) {
         %4 = bitcast i64 %0 to double
         %5 = bitcast i64 %1 to double
         %6 = fmul double %4, %5 ; XOR-ed sign
         %7 = call double @llvm.copysign.fp64(double %4, double %6)
         %8 = bitcast double %7 to i64
         ret i64 %8
      }
  FCLASS_D:
    func: |
      define i64 @FCLASS_D(i64 %0, i10 %rm) {
        %3 = bitcast i64 %0 to double
        %is_snan = call i1 @llvm.is.fpclass(double %3, i32 1)
        %is_qnan = call i1 @llvm.is.fpclass(double %3, i32 2)
        %is_neginf = call i1 @llvm.is.fpclass(double %3, i32 4)
        %is_negnorm = call i1 @llvm.is.fpclass(double %3, i32 8)
        %is_negsub = call i1 @llvm.is.fpclass(double %3, i32 16)
        %is_negzero = call i1 @llvm.is.fpclass(double %3, i32 32)
        %is_poszero = call i1 @llvm.is.fpclass(double %3, i32 64)
        %is_possub = call i1 @llvm.is.fpclass(double %3, i32 128)
        %is_posnorm = call i1 @llvm.is.fpclass(double %3, i32 256)
        %is_posinf = call i1 @llvm.is.fpclass(double %3, i32 512)
        ; shifting
        %is_neginf_shifted = zext i1 %is_neginf to i64 ; 0th
        %is_negnorm_zext = zext i1 %is_negnorm to i64
        %is_negnorm_shifted = shl i64 %is_negnorm_zext, 1
        %is_negsub_zext = zext i1 %is_negsub to i64
        %is_negsub_shifted = shl i64 %is_negsub_zext, 2
        %is_negzero_zext = zext i1 %is_negzero to i64
        %is_negzero_shifted = shl i64 %is_negzero_zext, 3
        %is_poszero_zext = zext i1 %is_poszero to i64
        %is_poszero_shifted = shl i64 %is_poszero_zext, 4
        %is_possub_zext = zext i1 %is_possub to i64
        %is_possub_shifted = shl i64 %is_possub_zext, 5
        %is_posnorm_zext = zext i1 %is_posnorm to i64
        %is_posnorm_shifted = shl i64 %is_posnorm_zext, 6
        %is_posinf_zext = zext i1 %is_posinf to i64
        %is_posinf_shifted = shl i64 %is_posinf_zext, 7
        %is_snan_zext = zext i1 %is_snan to i64
        %is_snan_shifted = shl i64 %is_snan_zext, 8
        %is_qnan_zext = zext i1 %is_qnan to i64
        %is_qnan_shifted = shl i64 %is_qnan_zext, 9
        %4 = or i64 %is_neginf_shifted, %is_negnorm_shifted
        %5 = or i64 %4, %is_negsub_shifted
        %6 = or i64 %5, %is_negzero_shifted
        %7 = or i64 %6, %is_poszero_shifted
        %8 = or i64 %7, %is_possub_shifted
        %9 = or i64 %8, %is_posnorm_shifted
        %10 = or i64 %9, %is_posinf_shifted
        %11 = or i64 %10, %is_snan_shifted
        %12 = or i64 %10, %is_qnan_shifted
        ret i64 %12
      }
  FCVT_D_LU:
    func: |
      define i64 @FCVT_D_LU(i64 %0, i10 %rm) {
         %3 = uitofp i64 %0 to double
         %4 = bitcast double %3 to i64
         ret i64 %4
      }
  FCVT_WU_D:
    func: |
      define i64 @FCVT_WU_D(i64 %0, i10 %rm) {
         %3 = bitcast i64 %0 to double
         %4 = fptoui double %3 to i32
         %5 = sext i32 %4 to i64
         ret i64 %5
      }
  FCVT_D_WU:
    func: |
      define i64 @FCVT_D_WU(i64 %0, i10 %rm) {
         %3 = trunc i64 %0 to i32
         %4 = uitofp i32 %3 to double
         %5 = bitcast double %4 to i64
         ret i64 %5
      }
  FCVT_D_W:
    func: |
      define i64 @FCVT_D_W(i64 %0, i10 %rm) {
         %3 = trunc i64 %0 to i32
         %4 = sitofp i32 %3 to double
         %5 = bitcast double %4 to i64
         ret i64 %5
      }
  FCVT_W_D:
    func: |
      define i64 @FCVT_W_D(i64 %0, i10 %rm) {
         %3 = bitcast i64 %0 to double
         %4 = fptosi double %3 to i32
         %5 = zext i32 %4 to i64
         %6 = shl i64 4294967295, 32 ; 0xFFFFFFFF00000000
         %7 = or i64 %5, %6
         ret i64 %7
      }
  FCVT_L_D:
    func: |
      define i64 @FCVT_L_D(i64 %0, i10 %rm) {
         %3 = bitcast i64 %0 to double
         %4 = fptosi double %3 to i64
         ret i64 %4
      }
  FCVT_LU_D:
    func: |
      define i64 @FCVT_LU_D(i64 %0, i10 %rm) {
         %3 = bitcast i64 %0 to double
         %4 = fptoui double %3 to i64
         ret i64 %4
      }
  FCVT_D_L:
    func: |
      define i64 @FCVT_D_L(i64 %0, i10 %rm) {
         %3 = sitofp i64 %0 to double
         %4 = bitcast double %3 to i64
         ret i64 %4
      }
  FCVT_S_D:
    func: |
      define i64 @FCVT_S_D(i64 %0, i10 %rm) {
         %3 = bitcast i64 %0 to double
         %4 = fptrunc double %3 to float
         %5 = bitcast float %4 to i32
         %6 = zext i32 %5 to i64
         %7 = shl i64 4294967295, 32 ; 0xFFFFFFFF00000000
         %8 = or i64 %6, %7
         ret i64 %8
      }
  FCVT_D_S:
    func: |
      define i64 @FCVT_D_S(i64 %0, i10 %rm) {
         %3 = trunc i64 %0 to i32
         %4 = bitcast i32 %3 to float
         %5 = fpext float %4 to double
         %6 = bitcast double %5 to i64
         ret i64 %6
      }
  FMADD_D:
    func: |
      define i64 @FMADD_D(i64 %0, i64 %1, i64 %2, i10 %rm) {
         %4 = bitcast i64 %0 to double
         %5 = bitcast i64 %1 to double
         %6 = bitcast i64 %2 to double
         %8 = call double @llvm.fmuladd.f64(double %4, double %5, double %6)
         %9 = bitcast double %8 to i64
         ret i64 %9
      }
  FMSUB_D:
    func: |
      define i64 @FMSUB_D(i64 %0, i64 %1, i64 %2, i10 %rm) {
         %4 = bitcast i64 %0 to double
         %5 = bitcast i64 %1 to double
         %6 = bitcast i64 %2 to double
         %7 = fneg double %6
         %8 = call double @llvm.fmuladd.f64(double %4, double %5, double %7)
         %9 = bitcast double %8 to i64
         ret i64 %9
      }
  FNMADD_D:
    func: |
      define i64 @FNMADD_D(i64 %0, i64 %1, i64 %2, i10 %rm) {
         %4 = bitcast i64 %0 to double
         %5 = bitcast i64 %1 to double
         %6 = bitcast i64 %2 to double
         %7 = fneg double %4
         %8 = fneg double %6
         %9 = call double @llvm.fmuladd.f64(double %7, double %5, double %8)
         %10 = bitcast double %9 to i64
         ret i64 %10
      }
  FNMSUB_D:
    func: |
      define i64 @FNMSUB_D(i64 %0, i64 %1, i64 %2, i10 %rm) {
         %4 = bitcast i64 %0 to double
         %5 = bitcast i64 %1 to double
         %6 = bitcast i64 %2 to double
         %7 = fneg double %4
         %9 = call double @llvm.fmuladd.f64(double %7, double %5, double %6)
         %10 = bitcast double %9 to i64
         ret i64 %10
      }
  FMV_X_D:
    func: |
      define i64 @FMV_X_D(i64 %0, i10 %rm) {
         ret i64 %0
      }
  FMV_D_X:
    func: |
      define i64 @FMV_D_X(i64 %0) {
         ret i64 %0
      }
  FLD: # Dummy implementation
    func: |
      define i64 @FLD(i64 %0, i64 %1) {
        %3 = add i64 0, 0
        ret i64 %3
      }
  FSD: # Dummy implementation
    func: |
      define void @FSD(i64 %0, i64 %1, i64 %2) {
        ret void
      }
  # basic ISA
  SLT:
    func: |
      define i\xlen\ @SLT(i\xlen\ noundef %0, i\xlen\ noundef %1) {
        %3 = icmp slt i\xlen\ %0, %1
        %4 = zext i1 %3 to i\xlen\
        ret i\xlen\ %4
      }
  SLTU:
    func: |
      define i\xlen\ @SLTU(i\xlen\ noundef %0, i\xlen\ noundef %1) {
        %3 = icmp ult i\xlen\ %0, %1
        %4 = zext i1 %3 to i\xlen\
        ret i\xlen\ %4
      }
  SLTIU:
    func: |
      define i\xlen\ @SLTIU(i\xlen\ noundef %0, i\xlen\ noundef %1) {
        %3 = icmp ult i\xlen\ %0, %1
        %4 = zext i1 %3 to i\xlen\
        ret i\xlen\ %4
      }
  AND:
    func: |
      define i\xlen\ @AND(i\xlen\ noundef %0, i\xlen\ noundef %1) {
        %3 = and i\xlen\ %1, %0
        ret i\xlen\ %3
      }
  OR:
    func: |
      define i\xlen\ @OR(i\xlen\ noundef %0, i\xlen\ noundef %1) {
        %3 = or i\xlen\ %1, %0
        ret i\xlen\ %3
      }
  XOR:
    func: |
      define i\xlen\ @XOR(i\xlen\ noundef %0, i\xlen\ noundef %1) {
        %3 = xor i\xlen\ %1, %0
        ret i\xlen\ %3
      }
  ORI:
    func: |
      define i\xlen\ @ORI(i\xlen\ noundef %0, i\xlen\ noundef %1) {
        %3 = or i\xlen\ %1, %0
        ret i\xlen\ %3
      }
  XORI:
    func: |
      define i\xlen\ @XORI(i\xlen\ noundef %0, i\xlen\ noundef %1) {
        %3 = xor i\xlen\ %1, %0
        ret i\xlen\ %3
      }
  SLL:
    func: |
      define i\xlen\ @SLL(i\xlen\ noundef %0, i\xlen\ noundef %1) {
        %3 = and i\xlen\ %1, \xlen - 1\
        %4 = shl i\xlen\ %0, %3
        ret i\xlen\ %4
      }
  SLLW:
    requires: rv64
    func: |
      define i\xlen\ @SLLW(i\xlen\ noundef %0, i\xlen\ noundef %1) {
        %3 = trunc i64 %1 to i32
        %4 = trunc i64 %0 to i32
        %5 = and i32 %3, 31
        %6 = shl i32 %4, %5
        %7 = sext i32 %6 to i64
        ret i64 %7
      }
  SRLW:
    requires: rv64
    func: |
      define i\xlen\ @SRLW(i\xlen\ noundef %0, i\xlen\ noundef %1) {
        %3 = trunc i64 %1 to i32
        %4 = trunc i64 %0 to i32
        %5 = and i32 %3, 31
        %6 = lshr i32 %4, %5
        %7 = sext i32 %6 to i64
        ret i64 %7
      }
  SRAW:
    requires: rv64
    func: |
      define i\xlen\ @SRAW(i\xlen\ noundef %0, i\xlen\ noundef %1) {
        %3 = trunc i64 %0 to i32
        %4 = trunc i64 %1 to i32
        %5 = and i32 %4, 31
        %6 = ashr i32 %3, %5
        %7 = sext i32 %6 to i64
        ret i64 %7
      }
  SLLI:
    func: |
      define i\xlen\ @SLLI(i\xlen\ noundef %0, i\xlen\ noundef %1) {
        %3 = and i\xlen\ %1, \xlen - 1\
        %4 = shl i\xlen\ %0, %3
        ret i\xlen\ %4
      }
  SRL:
    func: |
      define i\xlen\ @SRL(i\xlen\ noundef %0, i\xlen\ noundef %1) {
        %3 = and i\xlen\ %1, \xlen - 1\
        %4 = lshr i\xlen\ %0, %3
        ret i\xlen\ %4
      }
  SRA:
    func: |
      define i\xlen\ @SRA(i\xlen\ noundef %0, i\xlen\ noundef %1) {
        %3 = and i\xlen\ %1, \xlen - 1\
        %4 = ashr i\xlen\ %0, %3
        ret i\xlen\ %4
      }
  SRLI:
    func: |
      define i\xlen\ @SRLI(i\xlen\ noundef %0, i\xlen\ noundef %1) {
        %3 = and i\xlen\ %1, \xlen - 1\
        %4 = lshr i\xlen\ %0, %3
        ret i\xlen\ %4
      }
  SRAI:
    func: |
      define i\xlen\ @SRAI(i\xlen\ noundef %0, i\xlen\ noundef %1) {
        %3 = and i\xlen\ %1, \xlen - 1\
        %4 = ashr i\xlen\ %0, %3
        ret i\xlen\ %4
      }
  SLLIW:
    requires: rv64
    func: |
      define i64 @SLLIW(i64 noundef %0, i64 noundef %1) {
        %3 = trunc i64 %0 to i32
        %4 = trunc i64 %1 to i32
        %5 = and i32 %4, 63
        %6 = shl i32 %3, %5
        %7 = sext i32 %6 to i64
        ret i64 %7
      }
  SRLIW:
    requires: rv64
    func: |
      define i64 @SRLIW(i64 noundef %0, i64 noundef %1) {
        %3 = trunc i64 %0 to i32
        %4 = trunc i64 %1 to i32
        %5 = and i32 %4, 63
        %6 = lshr i32 %3, %5
        %7 = sext i32 %6 to i64
        ret i64 %7
      }
  SRAIW:
    requires: rv64
    func: |
      define i64 @SRAIW(i64 noundef %0, i64 noundef %1) {
        %3 = trunc i64 %0 to i32
        %4 = trunc i64 %1 to i32
        %6 = ashr i32 %3, %4
        %7 = sext i32 %6 to i64
        ret i64 %7
      }
  ADD:
    func: |
      define i\xlen\ @ADD(i\xlen\ noundef signext %0, i\xlen\ noundef signext %1) {
        %3 = add i\xlen\ %1, %0
        ret i\xlen\ %3
      }
  SUB:
    func: |
      define i\xlen\ @SUB(i\xlen\ noundef signext %0, i\xlen\ noundef signext %1) {
        %3 = sub i\xlen\ %0, %1
        ret i\xlen\ %3
      }
  SUBW:
    requires: rv64
    func: |
      define i64 @SUBW(i64 noundef signext %0, i64 noundef signext %1) {
        %3 = trunc i64 %0 to i32
        %4 = trunc i64 %1 to i32
        %5 = sub i32 %3, %4
        %6 = sext i32 %5 to i64
        ret i64 %6
      }
  ADDW:
    requires: rv64
    func: |
      define i64 @ADDW(i64 noundef signext %0, i64 noundef signext %1) {
        %3 = trunc i64 %0 to i32
        %4 = trunc i64 %1 to i32
        %5 = add i32 %3, %4
        %6 = sext i32 %5 to i64
        ret i64 %6
      }
  COPY:
    func: |
      define i\xlen\ @COPY(i\xlen\ noundef signext %0) {
        ret i\xlen\ %0
      }
  MULW:
    requires: rv64
    func: |
      define i64 @MULW(i64 %0, i64 %1) {
        %3 = trunc i64 %0 to i32
        %4 = trunc i64 %1 to i32
        %5 = mul i32 %3, %4
        %6 = sext i32 %5 to i64
        ret i64 %6
      }
  MUL:
    func: |
      define signext i\xlen\ @MUL(i\xlen\ noundef signext %0, i\xlen\ noundef signext %1) {
        %3 = mul i\xlen\ %0, %1
        ret i\xlen\ %3
      }
  MULH:
    requires: rv64
    func: |
      define i64 @MULH(i64 %0, i64 %1) {
        %3 = sext i64 %0 to i128
        %4 = sext i64 %1 to i128
        %5 = mul nsw i128 %3, %4
        %6 = lshr i128 %5, 64
        %7 = trunc nuw i128 %6 to i64
        ret i64 %7
      }
  MULHU:
    requires: rv64
    func: |
      define i64 @MULHU(i64 %0, i64 %1) {
        %3 = zext i64 %0 to i128
        %4 = zext i64 %1 to i128
        %5 = mul nuw i128 %3, %4
        %6 = lshr i128 %5, 64
        %7 = trunc nuw i128 %6 to i64
        ret i64 %7
      }
  MULHSU:
    requires: rv64
    func: |
      define i64 @MULHSU(i64 %0, i64 %1) {
        %3 = sext i64 %0 to i128
        %4 = zext i64 %1 to i128
        %5 = mul nsw i128 %3, %4
        %6 = lshr i128 %5, 64
        %7 = trunc nuw i128 %6 to i64
        ret i64 %7
      }
  DIV:
    func: |
      define signext i\xlen\ @DIV(i\xlen\ noundef signext %0, i\xlen\ noundef signext %1) {
        %3 = sdiv i\xlen\ %0, %1
        ret i\xlen\ %3
      }
  DIVW:
    requires: rv64
    func: |
      define i64 @DIVW(i64 %0, i64 %1) {
        %3 = trunc i64 %0 to i32
        %4 = trunc i64 %1 to i32
        %5 = sdiv i32 %3, %4
        %6 = sext i32 %5 to i64
        ret i64 %6
      }
  DIVU:
    requires: rv64
    func: |
      define i64 @DIVU(i64 %0, i64 %1) {
        %3 = udiv i64 %0, %1
        ret i64 %3
      }
  DIVUW:
    requires: rv64
    func: |
      define i64 @DIVUW(i64 %0, i64 %1) {
        %3 = trunc i64 %0 to i32
        %4 = trunc i64 %1 to i32
        %5 = udiv i32 %3, %4
        %6 = sext i32 %5 to i64
        ret i64 %6
      }
  REM:
    func: |
      define signext i\xlen\ @REM(i\xlen\ noundef signext %0, i\xlen\ noundef signext %1) {
        %3 = srem i\xlen\ %0, %1
        ret i\xlen\ %3
      }
  REMW:
    requires: rv64
    func: |
      define i64 @REMW(i64 %0, i64 %1) {
        %3 = trunc i64 %0 to i32
        %4 = trunc i64 %1 to i32
        %5 = srem i32 %3, %4
        %6 = sext i32 %5 to i64
        ret i64 %6
      }
  REMU:
    requires: rv64
    func: |
      define i64 @REMU(i64 %0, i64 %1) {
        %3 = urem i64 %0, %1
        ret i64 %3
      }
  REMUW:
    requires: rv64
    func: |
      define i64 @REMUW(i64 %0, i64 %1) {
        %3 = trunc i64 %0 to i32
        %4 = trunc i64 %1 to i32
        %5 = urem i32 %3, %4
        %6 = sext i32 %5 to i64
        ret i64 %6
      }
  LUI:
    func: |
      define signext i\xlen\ @LUI(i64 noundef signext %0) {
        %2 = trunc nuw i\xlen\ %0 to i20
        %3 = sext i20 %2 to i\xlen\
        %4 = shl i\xlen\ %3, 12
        ret i\xlen\ %4
      }
  ADDI:
    func: |
      define signext i\xlen\ @ADDI(i\xlen\ noundef signext %0, i\xlen\ noundef signext %1) {
        %3 = add i\xlen\ %0, %1
        ret i\xlen\ %3
      }
  ADDIW:
    requires: rv64
    func: |
      define signext i64 @ADDIW(i64 noundef signext %0, i64 noundef signext %1) {
        %3 = trunc i64 %1 to i32
        %4 = trunc i64 %0 to i32
        %5 = add i32 %3, %4
        %6 = sext i32 %5 to i64
        ret i64 %6
      }
  SD:
    requires: rv64
    func: |
      define void @SD(i64 %val, i64 %rs1, i64 %offset) {
        %3 = add i64 %rs1, %offset
        %4 = inttoptr i64 %3 to ptr
        store i64 %val, ptr %4, align 8
        ret void
      }
  LD:
    requires: rv64
    func: |
      define i64 @LD(i64 %rs1, i64 %offset) {
        %3 = add i64 %rs1, %offset
        %4 = inttoptr i64 %3 to ptr
        %5 = load i64, ptr %4
        ret i64 %5
      }
  SW:
    func: |
      define void @SW(i\xlen\ %val, i\xlen\ %rs1, i\xlen\ %offset) {
        %v = zext i32 -1 to i64
        %3 = and i64 %val, %v
        %4 = trunc i64 %val to i32
        %5 = add i\xlen\ %rs1, %offset
        %6 = inttoptr i\xlen\ %5 to ptr
        store i32 %4, ptr %6, align 4
        ret void
      }
  LW:
    func: |
      define i32 @LW(i\xlen\ %rs1, i\xlen\ %offset) {
        %3 = add i\xlen\ %rs1, %offset
        %4 = inttoptr i\xlen\ %3 to ptr
        %5 = load i32, ptr %4
        ret i32 %5
      }
  C_JR:
    is_return: [X1]
  JALR:
    # JALR is a return if it looks like: $x0 = JALR $x1, 0
    is_return: [X0, X1, 0]
    is_indirect_branch: true
  BNE:
    func: |
      define i1 @BNE(i\xlen\ noundef signext %0, i\xlen\ noundef signext %1) {
        %3 = icmp ne i\xlen\ %0, %1
        ret i1 %3
      }
  BEQ:
    func: |
      define i1 @BEQ(i\xlen\ noundef signext %0, i\xlen\ noundef signext %1) {
        %3 = icmp eq i\xlen\ %0, %1
        ret i1 %3
      }
  BLT:
    func: |
      define i1 @BLT(i\xlen\ noundef signext %0, i\xlen\ noundef signext %1) {
        %3 = icmp slt i\xlen\ %0, %1
        ret i1 %3
      }
  BGT:
    func: |
      define i1 @BGT(i\xlen\ noundef signext %0, i\xlen\ noundef signext %1) {
        %3 = icmp sgt i\xlen\ %0, %1
        ret i1 %3
      }
  BLE:
    func: |
      define i1 @BLE(i\xlen\ noundef signext %0, i\xlen\ noundef signext %1) {
        %3 = icmp sle i\xlen\ %0, %1
        ret i1 %3
      }
  BGE:
    func: |
      define i1 @BGE(i\xlen\ noundef signext %0, i\xlen\ noundef signext %1) {
        %3 = icmp sge i\xlen\ %0, %1
        ret i1 %3
      }
  BLTU:
    func: |
      define i1 @BLTU(i\xlen\ noundef signext %0, i\xlen\ noundef signext %1) {
        %3 = icmp ult i\xlen\ %0, %1
        ret i1 %3
      }
  BGEU:
    func: |
      define i1 @BGEU(i\xlen\ noundef signext %0, i\xlen\ noundef signext %1) {
        %3 = icmp uge i\xlen\ %0, %1
        ret i1 %3
      }
  FENCE:
    func: |
      define void @FENCE(i\xlen\ noundef signext %pred, i\xlen\ noundef signext %succ) {
        fence acq_rel
        ret void
      }
  FENCE_TSO:
    func: |
      define void @FENCE_TSO(i\xlen\ noundef signext %pred, i\xlen\ noundef signext %succ) {
        fence acq_rel
        ret void
      }
  EBREAK:
    func: |
      define void @EBREAK() {
        call void @llvm.debugtrap()
        ret void
      }
